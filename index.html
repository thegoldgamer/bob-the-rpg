<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>bob - The RPG — Game</title>
  <style>
    :root {
      --game-width: 1366px;
      --game-height: 768px;
      --page-bg: #0b0b0b;
      --panel-bg: #0f1720;
      --accent: #3ddc84;
    }

    /* --- overflow / centering hardening --- */
    html, body { overflow-x: hidden !important; overflow-y: scroll; }
    * { max-width: 100vw; box-sizing: border-box; }
    .page { width: 100%; max-width: 100vw; padding-left: 12px; padding-right: 12px; box-sizing: border-box; margin: 0 auto; }
    /* --- end hardening --- */

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      overflow-x: hidden !important;
      max-width: 100vw;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg, var(--page-bg), #071017);
      color: #e6eef8;
    }

    *, *::before, *::after { box-sizing: inherit; }

    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px 12px 48px;
      box-sizing: border-box;
      max-width: 100vw;
    }

    .game-wrapper {
      width: var(--game-width);
      height: var(--game-height);
      margin: 20px auto 0;
      background: var(--panel-bg);
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      flex: 0 0 auto;
      box-sizing: border-box;
      max-width: calc(100vw - 24px) !important;
      transition: background 240ms ease, box-shadow 240ms ease, border-radius 200ms ease;
    }

    /* Ambient backdrop element placed behind the iframe; shown only while fullscreen */
    .fs-backdrop {
      display: none;
      position: absolute;
      inset: 0;
      z-index: 6; /* behind iframe and full-screen controls */
      pointer-events: none;
      background: #000;
      filter: none;
      transform: scale(1.03);
      transition: opacity 300ms ease;
      opacity: 0.98;
    }

    /* When the wrapper is fullscreen, show the backdrop and darken background */
    .game-wrapper:fullscreen .fs-backdrop,
    .game-wrapper:-webkit-full-screen .fs-backdrop,
    .game-wrapper:-moz-full-screen .fs-backdrop,
    .game-wrapper:-ms-fullscreen .fs-backdrop {
      display: block;
    }

    .game-wrapper:fullscreen,
    .game-wrapper:-webkit-full-screen,
    .game-wrapper:-moz-full-screen,
    .game-wrapper:-ms-fullscreen {
      background: #000;      /* solid black background when fullscreen */
      box-shadow: none;
      border-radius: 0;
    }

    /* Fullscreen button */
    .fs-button {
      position: absolute;
      right: 8px;
      top: 8px;
      z-index: 50;
      background: rgba(0,0,0,0.6);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 8px 10px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .fs-button svg { width: 16px; height: 16px; display:block; }

    .game-frame {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      background: #000;
      z-index: 20;
      position: relative;
    }

    .placeholder { padding: 28px; text-align: center; color: #bcd7d1; }
    .hint { margin-top: 18px; font-size: 13px; color: #9fb8b0; }

    main.article { max-width: 860px; width: 100%; margin-top: 28px; color: #d9eef2; line-height: 1.5; }

    .mobile-overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(2,6,23,0.96); z-index: 9999; color: #e6eef8; padding: 28px; text-align: center;
    }
    .mobile-card { max-width: 420px; background: rgba(255,255,255,0.03); padding: 22px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.04); }
    .pc-icon { width: 72px; height: 72px; margin: 0 auto 12px; display: block; opacity: 0.95; }

    footer { margin: 48px 0 24px; color: #7ea59b; font-size: 13px; }

    @media (max-width: 920px) { .page { padding-left: 12px; padding-right: 12px; } }

  </style>
</head>
<body>
  <div class="page">
    <h1>bob - The RPG</h1>
    <p style="margin:0; color:#9fb8b0">Game preview — drop your exported HTML5 game into the <code>/game</code> folder.</p>

    <div class="game-wrapper" id="gameWrapper" role="region" aria-label="Game area">
      <!-- Ambient backdrop (shown while fullscreen) -->
      <div class="fs-backdrop" id="fsBackdrop" aria-hidden="true"></div>

      <!-- Fullscreen button -->
      <button id="fsButton" class="fs-button" title="Fullscreen (F)">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M7 14v3a1 1 0 0 1-1 1H3v-4h4zM7 10V7H3v4h4zM17 10V7h4v4h-4zM17 14v3h4v-4h-4z" stroke="#e6eef8" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Fullscreen
      </button>

      <!-- allowfullscreen + allow used for best behavior in various browsers -->
      <iframe id="gameFrame" class="game-frame" title="bob - The RPG game"
              src=""
              aria-label="Game frame"
              allow="fullscreen; autoplay; fullscreen *; geolocation; microphone; camera; clipboard-write; encrypted-media; display-capture"
              allowfullscreen
              scrolling="no"></iframe>

      <div id="placeholder" class="placeholder" style="display:none">
        <strong>No game found</strong>
        <div class="hint">Put your exported HTML5 game's files into the <code>/game</code> folder and make sure there's an <code>index.html</code> there.</div>
        <div class="hint">The page will try to auto-detect the game's canvas size and set the frame to those exact pixels.</div>
      </div>
    </div>

    <main class="article">
      <h2>About</h2>
      <p>This page loads <code>/game/index.html</code> in an iframe, auto-detects the exported game's canvas size, and forces nearest-neighbour rendering so pixel art stays sharp.</p>

      <h3>Quick checklist</h3>
      <ul>
        <li>Export your game from GameMaker as HTML5 and copy the export into <code>/game</code>.</li>
        <li>If the page can't detect the canvas (cross-origin or timing), set <code>--game-width</code> and <code>--game-height</code> at the top manually.</li>
      </ul>
    </main>

    <footer>Made with ♥ — drop your exported HTML5 into <code>/game</code>.</footer>
  </div>

  <div id="mobileOverlay" class="mobile-overlay">
    <div class="mobile-card">
      <svg class="pc-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="20" height="14" rx="2" stroke="#e6eef8" stroke-width="1.2" fill="rgba(255,255,255,0.02)"/><rect x="7" y="18" width="10" height="1.6" rx="0.5" fill="#e6eef8"/><rect x="11" y="20" width="2" height="0.8" rx="0.2" fill="#e6eef8"/></svg>
      <h3 style="margin:8px 0 6px">This game is for PC</h3>
      <p style="margin:0; color:#cfe6db">Please open this page on a desktop or laptop. The controls require keyboard and/or mouse and the page is not tuned for touch devices.</p>
    </div>
  </div>

  <script>
    (function() {
      var frame = document.getElementById('gameFrame');
      var placeholder = document.getElementById('placeholder');
      var wrapper = document.getElementById('gameWrapper');
      var overlay = document.getElementById('mobileOverlay');
      var fsButton = document.getElementById('fsButton');
      var fsBackdrop = document.getElementById('fsBackdrop');
      var gameUrl = './game/index.html';

      function showPlaceholder() { frame.style.display = 'none'; placeholder.style.display = 'block'; }
      function showFrame() { frame.style.display = 'block'; placeholder.style.display = 'none'; }

      function shouldShowMobileOverlay() {
        try {
          if (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) return true;
          if (/Mobi|Android|iPhone|iPad|Tablet/i.test(navigator.userAgent)) return true;
          if (window.innerWidth < 900) return true;
        } catch (e) {}
        return false;
      }

      function updateOverlayVisibility() {
        if (shouldShowMobileOverlay()) { overlay.style.display = 'flex'; wrapper.style.display = 'none'; }
        else { overlay.style.display = 'none'; wrapper.style.display = ''; }
      }

      updateOverlayVisibility();
      window.addEventListener('resize', function() { setTimeout(updateOverlayVisibility, 60); });

      // Fullscreen helpers
      function isFullscreen() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      }
      function updateFsButton() {
        var icon = '<svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M7 14v3a1 1 0 0 1-1 1H3v-4h4zM7 10V7H3v4h4zM17 10V7h4v4h-4zM17 14v3h4v-4h-4z" stroke="#e6eef8" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        fsButton.innerHTML = icon + (isFullscreen() ? 'Exit fullscreen' : 'Fullscreen');
      }

      function requestFullscreenOn(el) {
        if (!el) return Promise.reject();
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.mozRequestFullScreen) return el.mozRequestFullScreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
        return Promise.reject();
      }
      function exitFullscreen() {
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
        if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
        if (document.msExitFullscreen) return document.msExitFullscreen();
        return Promise.reject();
      }

      // toggle fullscreen (wrap the iframe so the parent can go fullscreen)
      function toggleFullscreen() {
        if (!isFullscreen()) {
          requestFullscreenOn(wrapper)
            .then(function() {
              try { frame.contentWindow && frame.contentWindow.focus && frame.contentWindow.focus(); } catch (e) {}
              updateFsButton();
            })
            .catch(function() {
              requestFullscreenOn(frame).then(updateFsButton).catch(updateFsButton);
            });
        } else {
          exitFullscreen().then(updateFsButton).catch(updateFsButton);
        }
      }

      // Ensure backdrop visibility syncs with fullscreen changes (works across vendors)
      function onFsChange() {
        var fs = isFullscreen();
        // When wrapper is fullscreen, the CSS :fullscreen rules will show the backdrop.
        // We still toggle an explicit class to support older browsers if needed.
        if (fs) wrapper.classList.add('is-fullscreen');
        else wrapper.classList.remove('is-fullscreen');
        updateFsButton();
      }

      // Button click + keyboard (F) to toggle
      fsButton.addEventListener('click', toggleFullscreen);
      window.addEventListener('keydown', function(e) {
        var t = e.target && e.target.tagName;
        if (t === 'INPUT' || t === 'TEXTAREA' || (e.target && e.target.isContentEditable)) return;
        if (e.key === 'f' || e.key === 'F') { e.preventDefault(); toggleFullscreen(); }
        if (e.key === 'Escape' && isFullscreen()) { exitFullscreen(); }
      });

      // update button when fullscreen changes
      document.addEventListener('fullscreenchange', onFsChange);
      document.addEventListener('webkitfullscreenchange', onFsChange);
      document.addEventListener('mozfullscreenchange', onFsChange);
      document.addEventListener('msfullscreenchange', onFsChange);

      // load game/index.html if present
      fetch(gameUrl, { method: 'GET' })
        .then(function(response) {
          if (!response.ok) { showPlaceholder(); return; }
          frame.setAttribute('allowfullscreen', '');
          frame.setAttribute('scrolling', 'no');
          frame.setAttribute('allow', 'fullscreen; autoplay; fullscreen *; geolocation; microphone; camera; clipboard-write; encrypted-media; display-capture');
          frame.src = gameUrl;
          showFrame();

          frame.addEventListener('load', function() {
            try {
              var win = frame.contentWindow;
              var doc = frame.contentDocument || win.document;

              try { if (doc && doc.documentElement) doc.documentElement.style.background = 'transparent'; } catch (e){}
              try { if (doc && doc.body) doc.body.style.margin = '0'; } catch(e){}

              function measureCanvasCSSSize(canvas) {
                try {
                  var rect = canvas.getBoundingClientRect();
                  var cssW = Math.round(rect.width);
                  var cssH = Math.round(rect.height);
                  if (!cssW || !cssH) { cssW = canvas.clientWidth || canvas.width || 1366; cssH = canvas.clientHeight || canvas.height || 768; }
                  return { cssW: cssW, cssH: cssH };
                } catch (e) { return null; }
              }

              function applyCanvas(canvas) {
                if (!canvas) return;
                var sizes = measureCanvasCSSSize(canvas);
                if (!sizes) { console.warn('Could not measure canvas CSS size (cross-origin?)'); return; }
                var cssW = sizes.cssW;
                var cssH = sizes.cssH;

                var maxAvailableW = Math.max(80, Math.floor(window.innerWidth - 24));
                if (cssW > maxAvailableW) {
                  var nativeW = canvas.width || cssW;
                  var scale = Math.floor(maxAvailableW / nativeW) || 1;
                  if (scale < 1) scale = maxAvailableW / cssW;
                  cssW = Math.round(nativeW * scale);
                  var nativeH = canvas.height || cssH;
                  cssH = Math.round(nativeH * scale);
                }

                document.documentElement.style.setProperty('--game-width', cssW + 'px');
                document.documentElement.style.setProperty('--game-height', cssH + 'px');
                wrapper.style.width = cssW + 'px';
                wrapper.style.height = cssH + 'px';
                wrapper.style.margin = '20px auto 0';
                wrapper.style.maxWidth = 'calc(100vw - 24px)';

                try {
                  frame.style.width = cssW + 'px';
                  frame.style.height = cssH + 'px';
                  frame.setAttribute('scrolling', 'no');
                  frame.style.overflow = 'hidden';
                } catch (e) {}

                try {
                  if (doc && doc.documentElement) doc.documentElement.style.overflow = 'hidden';
                  if (doc && doc.body) doc.body.style.overflow = 'hidden';
                } catch (e) {}

                try {
                  var style = doc.createElement('style');
                  style.type = 'text/css';
                  style.appendChild(doc.createTextNode('\nhtml,body{margin:0;background:transparent;overflow:hidden}\ncanvas{image-rendering: pixelated; image-rendering: crisp-edges; -ms-interpolation-mode: nearest-neighbor;}\n'));
                  (doc.head || doc.documentElement).appendChild(style);
                } catch (e) {}

                try {
                  canvas.style.imageRendering = 'pixelated';
                  canvas.style.setProperty('image-rendering', 'pixelated');
                  canvas.style.width = cssW + 'px';
                  canvas.style.height = cssH + 'px';
                } catch (e) {}

                try {
                  var contentW = (doc && (doc.documentElement.scrollWidth || (doc.body && doc.body.scrollWidth))) || cssW;
                  var contentH = (doc && (doc.documentElement.scrollHeight || (doc.body && doc.body.scrollHeight))) || cssH;
                  if (contentW > cssW || contentH > cssH) {
                    try {
                      if (doc && doc.documentElement) doc.documentElement.style.overflow = 'hidden';
                      if (doc && doc.body) doc.body.style.overflow = 'hidden';
                    } catch(e){}
                  }
                } catch(e){}
              }

              var tries = 0, maxTries = 90;
              var poll = setInterval(function() {
                tries++;
                var canvas = null;
                try { canvas = doc && (doc.querySelector('canvas') || doc.getElementsByTagName('canvas')[0]); } catch (e) { clearInterval(poll); console.warn('Cross-origin or blocked access to iframe; cannot auto-size.'); return; }
                if (canvas) { clearInterval(poll); applyCanvas(canvas); }
                else if (tries >= maxTries) { clearInterval(poll); console.warn('No canvas detected inside game iframe after polling.'); }
              }, 80);

            } catch (e) { console.warn('Error while accessing iframe content:', e); }
          });

        }).catch(function() { showPlaceholder(); });

      // Defensive JS mitigation: reapply caps and hide horizontal scroll if something else changes layout
      (function(){
        function clampLayout() {
          try {
            document.documentElement.style.overflowX = 'hidden';
            document.body.style.overflowY = 'scroll';
            var w = document.getElementById('gameWrapper');
            if (w) {
              w.style.maxWidth = 'calc(100vw - 24px)';
              w.style.left = '0';
              w.style.right = '0';
            }
          } catch(e){}
        }
        window.addEventListener('load', clampLayout);
        window.addEventListener('resize', clampLayout);
        setInterval(clampLayout, 800);
      })();

      // initialize button label/icon
      updateFsButton();
    })();
  </script>
</body>
</html>
